[
  {
    "projectId": "4fce6ce0-17a6-4d9c-80ee-4b0c8b0a283b",
    "testId": "2ff08a71-c2ad-4cae-aff3-b95573814bd2",
    "userId": "241844a8-a091-709f-311f-7ef21932865f",
    "title": "TC001-authentication session management",
    "description": "Verify user authentication and session management including login, logout, and password update functionalities to ensure session integrity and security.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_authentication_session_management():\n    # Test data\n    valid_user = {\"email\": \"testuser@example.com\", \"password\": \"correct_password\"}\n    invalid_user = {\"email\": \"testuser@example.com\", \"password\": \"wrong_password\"}\n    new_password = \"new_secure_password\"\n\n    session = requests.Session()\n    try:\n        # 1. Attempt login with valid credentials\n        resp = session.post(\n            f\"{BASE_URL}/api/auth/login\", json=valid_user, headers=HEADERS, timeout=TIMEOUT\n        )\n        assert resp.status_code == 200, f\"Login failed with valid credentials: {resp.text}\"\n        login_data = resp.json()\n        assert \"token\" in login_data and login_data[\"token\"], \"No session token received on login\"\n        token = login_data[\"token\"]\n\n        auth_headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n        # 2. Attempt login with invalid credentials\n        resp_invalid = requests.post(\n            f\"{BASE_URL}/api/auth/login\", json=invalid_user, headers=HEADERS, timeout=TIMEOUT\n        )\n        assert resp_invalid.status_code == 401 or resp_invalid.status_code == 400, \"Invalid login did not fail as expected\"\n\n        # 3. Validate session token usage by accessing protected endpoint (e.g. password update)\n        update_payload = {\"oldPassword\": valid_user[\"password\"], \"newPassword\": new_password}\n        resp_update_pw = session.put(\n            f\"{BASE_URL}/api/auth/password\",\n            json=update_payload,\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_update_pw.status_code == 200, f\"Password update failed: {resp_update_pw.text}\"\n\n        # 4. Verify that after password update, old password no longer works:\n        resp_old_pw_login = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json={\"email\": valid_user[\"email\"], \"password\": valid_user[\"password\"]},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_old_pw_login.status_code == 401 or resp_old_pw_login.status_code == 400, \"Old password login succeeded unexpectedly\"\n\n        # 5. Verify login with new password works\n        resp_new_pw_login = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json={\"email\": valid_user[\"email\"], \"password\": new_password},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_new_pw_login.status_code == 200, f\"Login with new password failed: {resp_new_pw_login.text}\"\n        new_login_data = resp_new_pw_login.json()\n        assert \"token\" in new_login_data and new_login_data[\"token\"], \"No session token received on login with new password\"\n\n        # 6. Logout via API\n        new_token = new_login_data[\"token\"]\n        logout_headers = {\"Authorization\": f\"Bearer {new_token}\", \"Content-Type\": \"application/json\"}\n        resp_logout = requests.post(f\"{BASE_URL}/api/auth/logout\", headers=logout_headers, timeout=TIMEOUT)\n        assert resp_logout.status_code == 200, f\"Logout failed: {resp_logout.text}\"\n\n        # 7. Access protected resource after logout to confirm token invalidation\n        resp_post_logout = requests.put(\n            f\"{BASE_URL}/api/auth/password\",\n            json={\"oldPassword\": new_password, \"newPassword\": valid_user[\"password\"]},\n            headers=logout_headers,\n            timeout=TIMEOUT,\n        )\n        assert resp_post_logout.status_code in (401, 403), \"Access with logged out token succeeded unexpectedly\"\n\n        # 8. Reset password back to original for idempotency if allowed by server after logout failure or via another login\n        resp_login_reset = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json={\"email\": valid_user[\"email\"], \"password\": new_password},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        if resp_login_reset.status_code == 200:\n            reset_token = resp_login_reset.json().get(\"token\")\n            if reset_token:\n                reset_headers = {\"Authorization\": f\"Bearer {reset_token}\", \"Content-Type\": \"application/json\"}\n                reset_pw_payload = {\"oldPassword\": new_password, \"newPassword\": valid_user[\"password\"]}\n                requests.put(\n                    f\"{BASE_URL}/api/auth/password\",\n                    json=reset_pw_payload,\n                    headers=reset_headers,\n                    timeout=TIMEOUT,\n                )\n\n    finally:\n        session.close()\n\n\ntest_authentication_session_management()\n",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T12:50:08.770Z",
    "modified": "2026-01-13T12:57:02.930Z"
  },
  {
    "projectId": "4fce6ce0-17a6-4d9c-80ee-4b0c8b0a283b",
    "testId": "53f58063-6f9a-4b91-ad7c-6da87efd8d60",
    "userId": "241844a8-a091-709f-311f-7ef21932865f",
    "title": "TC002-email synchronization trigger",
    "description": "Test the email synchronization API endpoint to ensure it correctly triggers the email sync process and handles success and failure scenarios.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_email_synchronization_trigger():\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    email_sync_url = f\"{BASE_URL}/api/email/sync\"\n\n    valid_credentials = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"correct_password\"\n    }\n    invalid_credentials = {\n        \"email\": \"testuser@example.com\",\n        \"password\": \"wrong_password\"\n    }\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # 1. Login with valid credentials to get a valid session token\n    resp_login_valid = requests.post(login_url, json=valid_credentials, headers=headers, timeout=TIMEOUT)\n    assert resp_login_valid.status_code == 200, f\"Valid login failed: {resp_login_valid.text}\"\n    token = resp_login_valid.json().get(\"token\")\n    assert token and isinstance(token, str), \"No token received on valid login\"\n\n    auth_headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n    # 2. Trigger email sync with valid token, expecting success\n    resp_sync_valid = requests.post(email_sync_url, headers=auth_headers, timeout=TIMEOUT)\n    assert resp_sync_valid.status_code == 200, f\"Email sync trigger failed with valid token: {resp_sync_valid.text}\"\n    # Assuming API returns JSON with success status\n    json_sync = resp_sync_valid.json()\n    assert json_sync.get(\"status\") == \"success\" or json_sync.get(\"message\"), \\\n        f\"Unexpected response content on valid email sync: {json_sync}\"\n\n    # 3. Attempt email sync with invalid token, expect auth failure (401 or 403)\n    invalid_auth_headers = {\"Authorization\": \"Bearer invalid_token_123\", \"Content-Type\": \"application/json\"}\n    resp_sync_invalid_token = requests.post(email_sync_url, headers=invalid_auth_headers, timeout=TIMEOUT)\n    assert resp_sync_invalid_token.status_code in (401, 403), \\\n        f\"Email sync did not fail as expected with invalid token: {resp_sync_invalid_token.status_code}\"\n\n    # 4. Attempt login with invalid credentials, expect failure (401)\n    resp_login_invalid = requests.post(login_url, json=invalid_credentials, headers=headers, timeout=TIMEOUT)\n    assert resp_login_invalid.status_code == 401, f\"Login succeeded with invalid credentials: {resp_login_invalid.text}\"\n\ntest_email_synchronization_trigger()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T12:50:08.777Z",
    "modified": "2026-01-13T12:57:02.941Z"
  },
  {
    "projectId": "4fce6ce0-17a6-4d9c-80ee-4b0c8b0a283b",
    "testId": "d8b40ca8-543a-4e1c-9fa5-2205032c9907",
    "userId": "241844a8-a091-709f-311f-7ef21932865f",
    "title": "TC003-email parsing functionality",
    "description": "Validate the email parsing API endpoint to confirm it accurately parses incoming emails and extracts relevant data without errors.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_email_parsing_functionality():\n    parse_email_url = f\"{BASE_URL}/api/email/parse\"\n    # Sample raw email data for parsing\n    sample_email = {\n        \"rawEmail\": \"\"\"From: sender@example.com\nTo: receiver@example.com\nSubject: Test Email Parsing\nDate: Fri, 13 Jan 2026 10:00:00 +0000\n\nThis is a test email for parsing functionality.\"\"\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        response = requests.post(parse_email_url, json=sample_email, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to parse email failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n    json_resp = response.json()\n    # Validate structure and expected keys in the parsing result\n    expected_keys = {\"from\", \"to\", \"subject\", \"date\", \"body\", \"headers\"}\n    assert isinstance(json_resp, dict), \"Response JSON is not a dictionary\"\n    assert expected_keys.issubset(json_resp.keys()), f\"Response JSON missing expected keys: {expected_keys - json_resp.keys()}\"\n    # Basic validation of parsed content values\n    assert json_resp[\"from\"] == \"sender@example.com\"\n    assert json_resp[\"to\"] == \"receiver@example.com\"\n    assert json_resp[\"subject\"] == \"Test Email Parsing\"\n    assert \"This is a test email for parsing functionality.\" in json_resp[\"body\"]\n\ntest_email_parsing_functionality()\n",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T12:50:08.783Z",
    "modified": "2026-01-13T12:57:02.949Z"
  },
  {
    "projectId": "4fce6ce0-17a6-4d9c-80ee-4b0c8b0a283b",
    "testId": "97d4d1e8-290c-4500-b6d2-0680b75aac2e",
    "userId": "241844a8-a091-709f-311f-7ef21932865f",
    "title": "TC004-leads management crud operations",
    "description": "Test the leads management API endpoints for full CRUD operations including creating, reading, updating, and deleting sales leads with data persistence in PostgreSQL.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_leads_management_crud_operations():\n    # Authenticate first to get a session token (assumed /api/auth/login endpoint with POST)\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    login_payload = {\n        \"username\": \"testuser\",\n        \"password\": \"testpassword\"\n    }\n    headers = {\"Content-Type\": \"application/json\"}\n    session = requests.Session()\n    try:\n        login_resp = session.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert \"token\" in login_data or \"accessToken\" in login_data, \"No session token in login response\"\n        token = login_data.get(\"token\") or login_data.get(\"accessToken\")\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # 1. CREATE a lead\n        create_url = f\"{BASE_URL}/api/leads\"\n        lead_payload = {\n            \"name\": \"Test Lead\",\n            \"email\": \"lead@example.com\",\n            \"phone\": \"1234567890\",\n            \"status\": \"new\",\n            \"source\": \"web\",\n            \"company\": \"Test Company\",\n            \"title\": \"Manager\",\n            \"notes\": \"Initial test lead\"\n        }\n        create_resp = session.post(create_url, json=lead_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert create_resp.status_code == 201, f\"Lead creation failed with status {create_resp.status_code}\"\n        lead_data = create_resp.json()\n        assert \"id\" in lead_data, \"Created lead response missing id\"\n        lead_id = lead_data[\"id\"]\n\n        # 2. READ the lead\n        read_url = f\"{BASE_URL}/api/leads/{lead_id}\"\n        read_resp = session.get(read_url, headers=auth_headers, timeout=TIMEOUT)\n        assert read_resp.status_code == 200, f\"Lead retrieval failed with status {read_resp.status_code}\"\n        read_data = read_resp.json()\n        for key in lead_payload:\n            assert read_data.get(key) == lead_payload[key], f\"Lead data mismatch on {key}\"\n\n        # 3. UPDATE the lead\n        update_url = f\"{BASE_URL}/api/leads/{lead_id}\"\n        update_payload = {\n            \"status\": \"contacted\",\n            \"notes\": \"Lead has been contacted\"\n        }\n        update_resp = session.put(update_url, json=update_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert update_resp.status_code == 200, f\"Lead update failed with status {update_resp.status_code}\"\n        updated_lead = update_resp.json()\n        assert updated_lead.get(\"status\") == \"contacted\", \"Lead status was not updated\"\n        assert updated_lead.get(\"notes\") == \"Lead has been contacted\", \"Lead notes were not updated\"\n\n        # 4. DELETE the lead\n        delete_url = f\"{BASE_URL}/api/leads/{lead_id}\"\n        delete_resp = session.delete(delete_url, headers=auth_headers, timeout=TIMEOUT)\n        assert delete_resp.status_code == 204, f\"Lead deletion failed with status {delete_resp.status_code}\"\n\n        # Confirm lead deletion\n        confirm_resp = session.get(read_url, headers=auth_headers, timeout=TIMEOUT)\n        assert confirm_resp.status_code == 404, \"Deleted lead still retrievable\"\n\n    finally:\n        # Cleanup in case lead still exists (best effort)\n        if 'lead_id' in locals():\n            try:\n                session.delete(f\"{BASE_URL}/api/leads/{lead_id}\", headers=auth_headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_leads_management_crud_operations()",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-13T12:50:08.789Z",
    "modified": "2026-01-13T12:57:02.958Z"
  }
]
